/**
 * AUTOMATICALLY GENERATED BY OPENFEATURE CLI. DO NOT MODIFY MANUALLY.
 *
 * This file contains generated typesafe Angular services and directives
 * for feature flags defined in your OpenFeature flag manifest.
 *
 * @openfeature/angular-sdk 1.1.0 or newer is required as a peer dependency.
 *
 * @see https://openfeature.dev
 */

import {
  ChangeDetectorRef,
  Directive,
  inject,
  Injectable,
  Input,
  OnChanges,
  TemplateRef,
  ViewContainerRef,
} from '@angular/core';
import {
  AngularFlagEvaluationOptions,
  EvaluationDetails,
  FeatureFlagDirective,
  FeatureFlagDirectiveContext,
  FeatureFlagService,
  JsonValue,
} from '@openfeature/angular-sdk';
import { Observable } from 'rxjs';

// ============================================================================
// FLAG KEYS
// ============================================================================

/**
 * Constant object containing all feature flag keys.
 * Use these constants to reference flag keys in a type-safe manner.
 */
export const FlagKeys = {
  /**
   * Flag key for Discount percentage applied to purchases..
   * - Type: `number`
   * - Default: `0.15`
   */
  DISCOUNT_PERCENTAGE: "discountPercentage",
  /**
   * Flag key for Controls whether Feature A is enabled..
   * - Type: `boolean`
   * - Default: `false`
   */
  ENABLE_FEATURE_A: "enableFeatureA",
  /**
   * Flag key for The message to use for greeting users..
   * - Type: `string`
   * - Default: `Hello there!`
   */
  GREETING_MESSAGE: "greetingMessage",
  /**
   * Flag key for Allows customization of theme colors..
   * - Type: `object`
   * - Default: `{"primaryColor":"#007bff","secondaryColor":"#6c757d"}`
   */
  THEME_CUSTOMIZATION: "themeCustomization",
  /**
   * Flag key for Maximum allowed length for usernames..
   * - Type: `number`
   * - Default: `50`
   */
  USERNAME_MAX_LENGTH: "usernameMaxLength",
} as const;

/**
 * Type representing all available flag keys.
 */
export type FlagKey = (typeof FlagKeys)[keyof typeof FlagKeys];

// ============================================================================
// GENERATED FEATURE FLAG SERVICE
// ============================================================================

/**
 * Generated typesafe feature flag service.
 * Provides strongly-typed methods for each feature flag defined in the manifest.
 *
 * @example
 * ```typescript
 * @Component({
 *   selector: 'app-my-component',
 *   template: `
 *     <div *ngIf="(myFlag$ | async)?.value">Feature enabled!</div>
 *   `
 * })
 * export class MyComponent {
 *   private flags = inject(GeneratedFeatureFlagService);
 *   myFlag$ = this.flags.getMyFlagDetails();
 * }
 * ```
 */
@Injectable({ providedIn: 'root' })
export class GeneratedFeatureFlagService {
  private readonly flagService = inject(FeatureFlagService);


  /**
   * Get evaluation details for the `discountPercentage` flag.
   *
   * Discount percentage applied to purchases.
   *
   * **Details:**
   * - Flag key: `discountPercentage`
   * - Type: `number`
   * - Default value: `0.15`
   *
   * @param domain - Optional domain for flag evaluation (scopes the flag to a specific provider).
   * @param options - Optional configuration for the flag evaluation.
   * @returns An Observable that emits EvaluationDetails whenever the flag value changes.
   */
  getDiscountPercentageDetails(
    domain?: string,
    options?: AngularFlagEvaluationOptions
  ): Observable<EvaluationDetails<number>> {
    return this.flagService.getNumberDetails(
      "discountPercentage",
      0.15,
      domain,
      {
        updateOnConfigurationChanged: options?.updateOnConfigurationChanged ?? true,
        updateOnContextChanged: options?.updateOnContextChanged ?? true,
      }
    );
  }

  /**
   * Get evaluation details for the `enableFeatureA` flag.
   *
   * Controls whether Feature A is enabled.
   *
   * **Details:**
   * - Flag key: `enableFeatureA`
   * - Type: `boolean`
   * - Default value: `false`
   *
   * @param domain - Optional domain for flag evaluation (scopes the flag to a specific provider).
   * @param options - Optional configuration for the flag evaluation.
   * @returns An Observable that emits EvaluationDetails whenever the flag value changes.
   */
  getEnableFeatureADetails(
    domain?: string,
    options?: AngularFlagEvaluationOptions
  ): Observable<EvaluationDetails<boolean>> {
    return this.flagService.getBooleanDetails(
      "enableFeatureA",
      false,
      domain,
      {
        updateOnConfigurationChanged: options?.updateOnConfigurationChanged ?? true,
        updateOnContextChanged: options?.updateOnContextChanged ?? true,
      }
    );
  }

  /**
   * Get evaluation details for the `greetingMessage` flag.
   *
   * The message to use for greeting users.
   *
   * **Details:**
   * - Flag key: `greetingMessage`
   * - Type: `string`
   * - Default value: `Hello there!`
   *
   * @param domain - Optional domain for flag evaluation (scopes the flag to a specific provider).
   * @param options - Optional configuration for the flag evaluation.
   * @returns An Observable that emits EvaluationDetails whenever the flag value changes.
   */
  getGreetingMessageDetails(
    domain?: string,
    options?: AngularFlagEvaluationOptions
  ): Observable<EvaluationDetails<string>> {
    return this.flagService.getStringDetails(
      "greetingMessage",
      "Hello there!",
      domain,
      {
        updateOnConfigurationChanged: options?.updateOnConfigurationChanged ?? true,
        updateOnContextChanged: options?.updateOnContextChanged ?? true,
      }
    );
  }

  /**
   * Get evaluation details for the `themeCustomization` flag.
   *
   * Allows customization of theme colors.
   *
   * **Details:**
   * - Flag key: `themeCustomization`
   * - Type: `JsonValue`
   * - Default value: `{"primaryColor":"#007bff","secondaryColor":"#6c757d"}`
   *
   * @param domain - Optional domain for flag evaluation (scopes the flag to a specific provider).
   * @param options - Optional configuration for the flag evaluation.
   * @returns An Observable that emits EvaluationDetails whenever the flag value changes.
   */
  getThemeCustomizationDetails(
    domain?: string,
    options?: AngularFlagEvaluationOptions
  ): Observable<EvaluationDetails<JsonValue>> {
    return this.flagService.getObjectDetails(
      "themeCustomization",
      {"primaryColor":"#007bff","secondaryColor":"#6c757d"},
      domain,
      {
        updateOnConfigurationChanged: options?.updateOnConfigurationChanged ?? true,
        updateOnContextChanged: options?.updateOnContextChanged ?? true,
      }
    );
  }

  /**
   * Get evaluation details for the `usernameMaxLength` flag.
   *
   * Maximum allowed length for usernames.
   *
   * **Details:**
   * - Flag key: `usernameMaxLength`
   * - Type: `number`
   * - Default value: `50`
   *
   * @param domain - Optional domain for flag evaluation (scopes the flag to a specific provider).
   * @param options - Optional configuration for the flag evaluation.
   * @returns An Observable that emits EvaluationDetails whenever the flag value changes.
   */
  getUsernameMaxLengthDetails(
    domain?: string,
    options?: AngularFlagEvaluationOptions
  ): Observable<EvaluationDetails<number>> {
    return this.flagService.getNumberDetails(
      "usernameMaxLength",
      50,
      domain,
      {
        updateOnConfigurationChanged: options?.updateOnConfigurationChanged ?? true,
        updateOnContextChanged: options?.updateOnContextChanged ?? true,
      }
    );
  }

}

// ============================================================================
// GENERATED STRUCTURAL DIRECTIVES
// ============================================================================



/**
 * Structural directive for the `discountPercentage` feature flag.
 *
 *Discount percentage applied to purchases.
 *
 * This directive extends `FeatureFlagDirective` from @openfeature/angular-sdk
 * with a pre-configured flag key and default value.
 *
 * **Details:**
 * - Flag key: `discountPercentage`
 * - Type: `number`
 * - Default value: `0.15`
 *
 *
 * @example
 * Explicit `ng-template` (no `*`), bind inputs directly
 * ```html
 * <ng-template discountPercentage
 *   [discountPercentageDefault]="defaultValue"
 *   [discountPercentageValue]="expectedValue"
 *   [discountPercentageElse]="elseTemplate"
 *   [discountPercentageInitializing]="initTemplate"
 *   [discountPercentageReconciling]="reconcilingTemplate">
 *   <div>Content shown when flag is matched.</div>
 * </ng-template>
 * <ng-template #elseTemplate>
 *   Content shown when flag is not matched.
 * </ng-template>
 * ```
 *
 * @example
 * Microsyntax `*` form, start with `let`
 * ```html
 * <div *discountPercentage="let v; value: expectedValue; else: elseTemplate; initializing: initTemplate; reconciling: reconcilingTemplate">
 *   Content shown when flag is matched.
 * </div>
 * ```
 *
 * @example
 * Simple `*` usage (no else/initializing/reconciling)
 * ```html
 * <div *discountPercentage="let v">
 *   Content shown when flag is matched.
 * </div>
 * ```
 *
 * @remarks
 * Note: Angular's microsyntax parser requires the first segment to be a primary
 * expression or a `let` declaration. Because the flag key is preconfigured, start with
 * `let v` or `let details = evaluationDetails` (or `let _` if you do not need the value)
 * before any `else`/`initializing`/`reconciling`/`default` segments.
 * This is an Angular microsyntax parsing constraint, not a directive limitation.
 * `*discountPercentage="else elseTemplate"` will not parse because `else` is a
 * secondary segment. If you do not need the value, use `let _`, or use the
 * explicit `ng-template` form above.
 */
@Directive({
  selector: '[discountPercentage]',
  standalone: true,
})
export class DiscountPercentageFeatureFlagDirective extends FeatureFlagDirective<number> implements OnChanges {
  override _changeDetectorRef = inject(ChangeDetectorRef);
  override _viewContainerRef = inject(ViewContainerRef);
  override _thenTemplateRef = inject<TemplateRef<FeatureFlagDirectiveContext<number>>>(TemplateRef);

  /**
   * The expected value of this number feature flag, for which the `then` template should be rendered.
   */
  @Input({ required: false }) discountPercentageValue?: number;

  constructor() {
    super();

    this._featureFlagKey = "discountPercentage";
    this._featureFlagDefault = 0.15;

  }

  override ngOnChanges() {
    super.ngOnChanges();

    this._featureFlagValue = this.discountPercentageValue;
  }

  /**
   * The domain of the number feature flag.
   */
  @Input({ required: false })
  set discountPercentageDomain(domain: string | undefined) {
    super.featureFlagDomain = domain;
  }

  /**
   * Update the component if the provider emits a ConfigurationChanged event.
   * Set to false to prevent components from re-rendering when flag value changes
   * are received by the associated provider.
   * Defaults to true.
   */
  @Input({ required: false })
  set discountPercentageUpdateOnConfigurationChanged(enabled: boolean | undefined) {
    this._updateOnConfigurationChanged = enabled ?? true;
  }

  /**
   * Update the component when the OpenFeature context changes.
   * Set to false to prevent components from re-rendering when attributes which
   * may be factors in flag evaluation change.
   * Defaults to true.
   */
  @Input({ required: false })
  set discountPercentageUpdateOnContextChanged(enabled: boolean | undefined) {
    this._updateOnContextChanged = enabled ?? true;
  }

  /**
   * Template to be displayed when the feature flag does not match value.
   */
  @Input()
  set discountPercentageElse(tpl: TemplateRef<FeatureFlagDirectiveContext<number>>) {
    this._elseTemplateRef = tpl;
  }

  /**
   * Template to be displayed when the provider is not ready.
   */
  @Input()
  set discountPercentageInitializing(tpl: TemplateRef<FeatureFlagDirectiveContext<number>>) {
    this._initializingTemplateRef = tpl;
  }

  /**
   * Template to be displayed when the provider is reconciling.
   */
  @Input()
  set discountPercentageReconciling(tpl: TemplateRef<FeatureFlagDirectiveContext<number>>) {
    this._reconcilingTemplateRef = tpl;
  }
}



/**
 * Structural directive for the `enableFeatureA` feature flag.
 *
 *Controls whether Feature A is enabled.
 *
 * This directive extends `FeatureFlagDirective` from @openfeature/angular-sdk
 * with a pre-configured flag key and default value.
 *
 * **Details:**
 * - Flag key: `enableFeatureA`
 * - Type: `boolean`
 * - Default value: `false`
 *
 *
 * @example
 * Explicit `ng-template` (no `*`), bind inputs directly
 * ```html
 * <ng-template enableFeatureA
 *   [enableFeatureADefault]="defaultValue"
 *   [enableFeatureAElse]="elseTemplate"
 *   [enableFeatureAInitializing]="initTemplate"
 *   [enableFeatureAReconciling]="reconcilingTemplate">
 *   <div>Content shown when flag is enabled.</div>
 * </ng-template>
 * <ng-template #elseTemplate>
 *   Content shown when flag is disabled.
 * </ng-template>
 * ```
 *
 * @example
 * Microsyntax `*` form, start with `let`
 * ```html
 * <div *enableFeatureA="let v; else: elseTemplate; initializing: initTemplate; reconciling: reconcilingTemplate">
 *   Content shown when flag is enabled.
 * </div>
 * ```
 *
 * @example
 * Simple `*` usage (no else/initializing/reconciling)
 * ```html
 * <div *enableFeatureA="let v">
 *   Content shown when flag is enabled.
 * </div>
 * ```
 *
 * @remarks
 * Note: Angular's microsyntax parser requires the first segment to be a primary
 * expression or a `let` declaration. Because the flag key is preconfigured, start with
 * `let v` or `let details = evaluationDetails` (or `let _` if you do not need the value)
 * before any `else`/`initializing`/`reconciling`/`default` segments.
 * This is an Angular microsyntax parsing constraint, not a directive limitation.
 * `*enableFeatureA="else elseTemplate"` will not parse because `else` is a
 * secondary segment. If you do not need the value, use `let _`, or use the
 * explicit `ng-template` form above.
 */
@Directive({
  selector: '[enableFeatureA]',
  standalone: true,
})
export class EnableFeatureAFeatureFlagDirective extends FeatureFlagDirective<boolean> implements OnChanges {
  override _changeDetectorRef = inject(ChangeDetectorRef);
  override _viewContainerRef = inject(ViewContainerRef);
  override _thenTemplateRef = inject<TemplateRef<FeatureFlagDirectiveContext<boolean>>>(TemplateRef);

  constructor() {
    super();

    this._featureFlagKey = "enableFeatureA";
    this._featureFlagDefault = false;

    this._featureFlagValue = true;

  }

  /**
   * The domain of the boolean feature flag.
   */
  @Input({ required: false })
  set enableFeatureADomain(domain: string | undefined) {
    super.featureFlagDomain = domain;
  }

  /**
   * Update the component if the provider emits a ConfigurationChanged event.
   * Set to false to prevent components from re-rendering when flag value changes
   * are received by the associated provider.
   * Defaults to true.
   */
  @Input({ required: false })
  set enableFeatureAUpdateOnConfigurationChanged(enabled: boolean | undefined) {
    this._updateOnConfigurationChanged = enabled ?? true;
  }

  /**
   * Update the component when the OpenFeature context changes.
   * Set to false to prevent components from re-rendering when attributes which
   * may be factors in flag evaluation change.
   * Defaults to true.
   */
  @Input({ required: false })
  set enableFeatureAUpdateOnContextChanged(enabled: boolean | undefined) {
    this._updateOnContextChanged = enabled ?? true;
  }

  /**
   * Template to be displayed when the feature flag is false.
   */
  @Input()
  set enableFeatureAElse(tpl: TemplateRef<FeatureFlagDirectiveContext<boolean>>) {
    this._elseTemplateRef = tpl;
  }

  /**
   * Template to be displayed when the provider is not ready.
   */
  @Input()
  set enableFeatureAInitializing(tpl: TemplateRef<FeatureFlagDirectiveContext<boolean>>) {
    this._initializingTemplateRef = tpl;
  }

  /**
   * Template to be displayed when the provider is reconciling.
   */
  @Input()
  set enableFeatureAReconciling(tpl: TemplateRef<FeatureFlagDirectiveContext<boolean>>) {
    this._reconcilingTemplateRef = tpl;
  }
}



/**
 * Structural directive for the `greetingMessage` feature flag.
 *
 *The message to use for greeting users.
 *
 * This directive extends `FeatureFlagDirective` from @openfeature/angular-sdk
 * with a pre-configured flag key and default value.
 *
 * **Details:**
 * - Flag key: `greetingMessage`
 * - Type: `string`
 * - Default value: `Hello there!`
 *
 *
 * @example
 * Explicit `ng-template` (no `*`), bind inputs directly
 * ```html
 * <ng-template greetingMessage
 *   [greetingMessageDefault]="defaultValue"
 *   [greetingMessageValue]="expectedValue"
 *   [greetingMessageElse]="elseTemplate"
 *   [greetingMessageInitializing]="initTemplate"
 *   [greetingMessageReconciling]="reconcilingTemplate">
 *   <div>Content shown when flag is matched.</div>
 * </ng-template>
 * <ng-template #elseTemplate>
 *   Content shown when flag is not matched.
 * </ng-template>
 * ```
 *
 * @example
 * Microsyntax `*` form, start with `let`
 * ```html
 * <div *greetingMessage="let v; value: expectedValue; else: elseTemplate; initializing: initTemplate; reconciling: reconcilingTemplate">
 *   Content shown when flag is matched.
 * </div>
 * ```
 *
 * @example
 * Simple `*` usage (no else/initializing/reconciling)
 * ```html
 * <div *greetingMessage="let v">
 *   Content shown when flag is matched.
 * </div>
 * ```
 *
 * @remarks
 * Note: Angular's microsyntax parser requires the first segment to be a primary
 * expression or a `let` declaration. Because the flag key is preconfigured, start with
 * `let v` or `let details = evaluationDetails` (or `let _` if you do not need the value)
 * before any `else`/`initializing`/`reconciling`/`default` segments.
 * This is an Angular microsyntax parsing constraint, not a directive limitation.
 * `*greetingMessage="else elseTemplate"` will not parse because `else` is a
 * secondary segment. If you do not need the value, use `let _`, or use the
 * explicit `ng-template` form above.
 */
@Directive({
  selector: '[greetingMessage]',
  standalone: true,
})
export class GreetingMessageFeatureFlagDirective extends FeatureFlagDirective<string> implements OnChanges {
  override _changeDetectorRef = inject(ChangeDetectorRef);
  override _viewContainerRef = inject(ViewContainerRef);
  override _thenTemplateRef = inject<TemplateRef<FeatureFlagDirectiveContext<string>>>(TemplateRef);

  /**
   * The expected value of this string feature flag, for which the `then` template should be rendered.
   */
  @Input({ required: false }) greetingMessageValue?: string;

  constructor() {
    super();

    this._featureFlagKey = "greetingMessage";
    this._featureFlagDefault = "Hello there!";

  }

  override ngOnChanges() {
    super.ngOnChanges();

    this._featureFlagValue = this.greetingMessageValue;
  }

  /**
   * The domain of the string feature flag.
   */
  @Input({ required: false })
  set greetingMessageDomain(domain: string | undefined) {
    super.featureFlagDomain = domain;
  }

  /**
   * Update the component if the provider emits a ConfigurationChanged event.
   * Set to false to prevent components from re-rendering when flag value changes
   * are received by the associated provider.
   * Defaults to true.
   */
  @Input({ required: false })
  set greetingMessageUpdateOnConfigurationChanged(enabled: boolean | undefined) {
    this._updateOnConfigurationChanged = enabled ?? true;
  }

  /**
   * Update the component when the OpenFeature context changes.
   * Set to false to prevent components from re-rendering when attributes which
   * may be factors in flag evaluation change.
   * Defaults to true.
   */
  @Input({ required: false })
  set greetingMessageUpdateOnContextChanged(enabled: boolean | undefined) {
    this._updateOnContextChanged = enabled ?? true;
  }

  /**
   * Template to be displayed when the feature flag does not match value.
   */
  @Input()
  set greetingMessageElse(tpl: TemplateRef<FeatureFlagDirectiveContext<string>>) {
    this._elseTemplateRef = tpl;
  }

  /**
   * Template to be displayed when the provider is not ready.
   */
  @Input()
  set greetingMessageInitializing(tpl: TemplateRef<FeatureFlagDirectiveContext<string>>) {
    this._initializingTemplateRef = tpl;
  }

  /**
   * Template to be displayed when the provider is reconciling.
   */
  @Input()
  set greetingMessageReconciling(tpl: TemplateRef<FeatureFlagDirectiveContext<string>>) {
    this._reconcilingTemplateRef = tpl;
  }
}



/**
 * Structural directive for the `themeCustomization` feature flag.
 *
 *Allows customization of theme colors.
 *
 * This directive extends `FeatureFlagDirective` from @openfeature/angular-sdk
 * with a pre-configured flag key and default value.
 *
 * **Details:**
 * - Flag key: `themeCustomization`
 * - Type: `JsonValue`
 * - Default value: `{"primaryColor":"#007bff","secondaryColor":"#6c757d"}`
 *
 *
 * @example
 * Explicit `ng-template` (no `*`), bind inputs directly
 * ```html
 * <ng-template themeCustomization
 *   [themeCustomizationDefault]="defaultValue"
 *   [themeCustomizationValue]="expectedValue"
 *   [themeCustomizationElse]="elseTemplate"
 *   [themeCustomizationInitializing]="initTemplate"
 *   [themeCustomizationReconciling]="reconcilingTemplate">
 *   <div>Content shown when flag is matched.</div>
 * </ng-template>
 * <ng-template #elseTemplate>
 *   Content shown when flag is not matched.
 * </ng-template>
 * ```
 *
 * @example
 * Microsyntax `*` form, start with `let`
 * ```html
 * <div *themeCustomization="let v; value: expectedValue; else: elseTemplate; initializing: initTemplate; reconciling: reconcilingTemplate">
 *   Content shown when flag is matched.
 * </div>
 * ```
 *
 * @example
 * Simple `*` usage (no else/initializing/reconciling)
 * ```html
 * <div *themeCustomization="let v">
 *   Content shown when flag is matched.
 * </div>
 * ```
 *
 * @remarks
 * Note: Angular's microsyntax parser requires the first segment to be a primary
 * expression or a `let` declaration. Because the flag key is preconfigured, start with
 * `let v` or `let details = evaluationDetails` (or `let _` if you do not need the value)
 * before any `else`/`initializing`/`reconciling`/`default` segments.
 * This is an Angular microsyntax parsing constraint, not a directive limitation.
 * `*themeCustomization="else elseTemplate"` will not parse because `else` is a
 * secondary segment. If you do not need the value, use `let _`, or use the
 * explicit `ng-template` form above.
 */
@Directive({
  selector: '[themeCustomization]',
  standalone: true,
})
export class ThemeCustomizationFeatureFlagDirective extends FeatureFlagDirective<JsonValue> implements OnChanges {
  override _changeDetectorRef = inject(ChangeDetectorRef);
  override _viewContainerRef = inject(ViewContainerRef);
  override _thenTemplateRef = inject<TemplateRef<FeatureFlagDirectiveContext<JsonValue>>>(TemplateRef);

  /**
   * The expected value of this object feature flag, for which the `then` template should be rendered.
   */
  @Input({ required: false }) themeCustomizationValue?: JsonValue;

  constructor() {
    super();

    this._featureFlagKey = "themeCustomization";
    this._featureFlagDefault = {"primaryColor":"#007bff","secondaryColor":"#6c757d"};

  }

  override ngOnChanges() {
    super.ngOnChanges();

    this._featureFlagValue = this.themeCustomizationValue;
  }

  /**
   * The domain of the object feature flag.
   */
  @Input({ required: false })
  set themeCustomizationDomain(domain: string | undefined) {
    super.featureFlagDomain = domain;
  }

  /**
   * Update the component if the provider emits a ConfigurationChanged event.
   * Set to false to prevent components from re-rendering when flag value changes
   * are received by the associated provider.
   * Defaults to true.
   */
  @Input({ required: false })
  set themeCustomizationUpdateOnConfigurationChanged(enabled: boolean | undefined) {
    this._updateOnConfigurationChanged = enabled ?? true;
  }

  /**
   * Update the component when the OpenFeature context changes.
   * Set to false to prevent components from re-rendering when attributes which
   * may be factors in flag evaluation change.
   * Defaults to true.
   */
  @Input({ required: false })
  set themeCustomizationUpdateOnContextChanged(enabled: boolean | undefined) {
    this._updateOnContextChanged = enabled ?? true;
  }

  /**
   * Template to be displayed when the feature flag does not match value.
   */
  @Input()
  set themeCustomizationElse(tpl: TemplateRef<FeatureFlagDirectiveContext<JsonValue>>) {
    this._elseTemplateRef = tpl;
  }

  /**
   * Template to be displayed when the provider is not ready.
   */
  @Input()
  set themeCustomizationInitializing(tpl: TemplateRef<FeatureFlagDirectiveContext<JsonValue>>) {
    this._initializingTemplateRef = tpl;
  }

  /**
   * Template to be displayed when the provider is reconciling.
   */
  @Input()
  set themeCustomizationReconciling(tpl: TemplateRef<FeatureFlagDirectiveContext<JsonValue>>) {
    this._reconcilingTemplateRef = tpl;
  }
}



/**
 * Structural directive for the `usernameMaxLength` feature flag.
 *
 *Maximum allowed length for usernames.
 *
 * This directive extends `FeatureFlagDirective` from @openfeature/angular-sdk
 * with a pre-configured flag key and default value.
 *
 * **Details:**
 * - Flag key: `usernameMaxLength`
 * - Type: `number`
 * - Default value: `50`
 *
 *
 * @example
 * Explicit `ng-template` (no `*`), bind inputs directly
 * ```html
 * <ng-template usernameMaxLength
 *   [usernameMaxLengthDefault]="defaultValue"
 *   [usernameMaxLengthValue]="expectedValue"
 *   [usernameMaxLengthElse]="elseTemplate"
 *   [usernameMaxLengthInitializing]="initTemplate"
 *   [usernameMaxLengthReconciling]="reconcilingTemplate">
 *   <div>Content shown when flag is matched.</div>
 * </ng-template>
 * <ng-template #elseTemplate>
 *   Content shown when flag is not matched.
 * </ng-template>
 * ```
 *
 * @example
 * Microsyntax `*` form, start with `let`
 * ```html
 * <div *usernameMaxLength="let v; value: expectedValue; else: elseTemplate; initializing: initTemplate; reconciling: reconcilingTemplate">
 *   Content shown when flag is matched.
 * </div>
 * ```
 *
 * @example
 * Simple `*` usage (no else/initializing/reconciling)
 * ```html
 * <div *usernameMaxLength="let v">
 *   Content shown when flag is matched.
 * </div>
 * ```
 *
 * @remarks
 * Note: Angular's microsyntax parser requires the first segment to be a primary
 * expression or a `let` declaration. Because the flag key is preconfigured, start with
 * `let v` or `let details = evaluationDetails` (or `let _` if you do not need the value)
 * before any `else`/`initializing`/`reconciling`/`default` segments.
 * This is an Angular microsyntax parsing constraint, not a directive limitation.
 * `*usernameMaxLength="else elseTemplate"` will not parse because `else` is a
 * secondary segment. If you do not need the value, use `let _`, or use the
 * explicit `ng-template` form above.
 */
@Directive({
  selector: '[usernameMaxLength]',
  standalone: true,
})
export class UsernameMaxLengthFeatureFlagDirective extends FeatureFlagDirective<number> implements OnChanges {
  override _changeDetectorRef = inject(ChangeDetectorRef);
  override _viewContainerRef = inject(ViewContainerRef);
  override _thenTemplateRef = inject<TemplateRef<FeatureFlagDirectiveContext<number>>>(TemplateRef);

  /**
   * The expected value of this number feature flag, for which the `then` template should be rendered.
   */
  @Input({ required: false }) usernameMaxLengthValue?: number;

  constructor() {
    super();

    this._featureFlagKey = "usernameMaxLength";
    this._featureFlagDefault = 50;

  }

  override ngOnChanges() {
    super.ngOnChanges();

    this._featureFlagValue = this.usernameMaxLengthValue;
  }

  /**
   * The domain of the number feature flag.
   */
  @Input({ required: false })
  set usernameMaxLengthDomain(domain: string | undefined) {
    super.featureFlagDomain = domain;
  }

  /**
   * Update the component if the provider emits a ConfigurationChanged event.
   * Set to false to prevent components from re-rendering when flag value changes
   * are received by the associated provider.
   * Defaults to true.
   */
  @Input({ required: false })
  set usernameMaxLengthUpdateOnConfigurationChanged(enabled: boolean | undefined) {
    this._updateOnConfigurationChanged = enabled ?? true;
  }

  /**
   * Update the component when the OpenFeature context changes.
   * Set to false to prevent components from re-rendering when attributes which
   * may be factors in flag evaluation change.
   * Defaults to true.
   */
  @Input({ required: false })
  set usernameMaxLengthUpdateOnContextChanged(enabled: boolean | undefined) {
    this._updateOnContextChanged = enabled ?? true;
  }

  /**
   * Template to be displayed when the feature flag does not match value.
   */
  @Input()
  set usernameMaxLengthElse(tpl: TemplateRef<FeatureFlagDirectiveContext<number>>) {
    this._elseTemplateRef = tpl;
  }

  /**
   * Template to be displayed when the provider is not ready.
   */
  @Input()
  set usernameMaxLengthInitializing(tpl: TemplateRef<FeatureFlagDirectiveContext<number>>) {
    this._initializingTemplateRef = tpl;
  }

  /**
   * Template to be displayed when the provider is reconciling.
   */
  @Input()
  set usernameMaxLengthReconciling(tpl: TemplateRef<FeatureFlagDirectiveContext<number>>) {
    this._reconcilingTemplateRef = tpl;
  }
}



// ============================================================================
// EXPORTS
// ============================================================================

/**
 * Array of all generated feature flag directives.
 * Import this in your module or standalone component to use the directives.
 *
 * @example
 * ```typescript
 * @Component({
 *   standalone: true,
 *   imports: [GeneratedFeatureFlagDirectives],
 *   template: `<div *myFeatureFlag>...</div>`
 * })
 * export class MyComponent {}
 * ```
 */
export const GeneratedFeatureFlagDirectives = [
  DiscountPercentageFeatureFlagDirective,
  EnableFeatureAFeatureFlagDirective,
  GreetingMessageFeatureFlagDirective,
  ThemeCustomizationFeatureFlagDirective,
  UsernameMaxLengthFeatureFlagDirective,
] as const;
