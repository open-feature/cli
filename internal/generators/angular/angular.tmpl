/**
 * AUTOMATICALLY GENERATED BY OPENFEATURE CLI. DO NOT MODIFY MANUALLY.
 *
 * This file contains generated typesafe Angular services and directives
 * for feature flags defined in your OpenFeature flag manifest.
 *
 * @openfeature/angular-sdk is required as a peer dependency.
 *
 * @see https://openfeature.dev
 */

import {
  Directive,
  inject,
  Injectable,
} from '@angular/core';
import {
  AngularFlagEvaluationOptions,
  BooleanFeatureFlagDirective,
  EvaluationDetails,
  FeatureFlagService,
  JsonValue,
  NumberFeatureFlagDirective,
  ObjectFeatureFlagDirective,
  StringFeatureFlagDirective,
} from '@openfeature/angular-sdk';
import { Observable } from 'rxjs';

// ============================================================================
// FLAG KEYS
// ============================================================================

/**
 * Constant object containing all feature flag keys.
 * Use these constants to reference flag keys in a type-safe manner.
 */
export const FlagKeys = {
{{- range .Flagset.Flags }}
  /**
   * Flag key for {{ if .Description }}{{ .Description }}{{ else }}this flag{{ end }}.
   * - Type: `{{ .Type | OpenFeatureType }}`
   * - Default: `{{ if eq (.Type | OpenFeatureType) "object"}}{{ .DefaultValue | ToJSONString }}{{ else }}{{ .DefaultValue }}{{ end }}`
   */
  {{ .Key | ToScreamingSnake }}: {{ .Key | Quote }},
{{- end }}
} as const;

/**
 * Type representing all available flag keys.
 */
export type FlagKey = (typeof FlagKeys)[keyof typeof FlagKeys];

// ============================================================================
// GENERATED FEATURE FLAG SERVICE
// ============================================================================

/**
 * Generated typesafe feature flag service.
 * Provides strongly-typed methods for each feature flag defined in the manifest.
 *
 * @example
 * ```typescript
 * @Component({
 *   selector: 'app-my-component',
 *   template: `
 *     <div *ngIf="(myFlag$ | async)?.value">Feature enabled!</div>
 *   `
 * })
 * export class MyComponent {
 *   private flags = inject(GeneratedFeatureFlagService);
 *   myFlag$ = this.flags.getMyFlagDetails();
 * }
 * ```
 */
@Injectable({ providedIn: 'root' })
export class GeneratedFeatureFlagService {
  private readonly flagService = inject(FeatureFlagService);

{{ range .Flagset.Flags }}
  /**
   * Get evaluation details for the `{{ .Key }}` flag.
   *
   * {{ if .Description }}{{ .Description }}{{ else }}Feature flag.{{ end }}
   *
   * **Details:**
   * - Flag key: `{{ .Key }}`
   * - Type: `{{ if eq (.Type | OpenFeatureType) "object" }}JsonValue{{ else }}{{ .Type | OpenFeatureType }}{{ end }}`
   * - Default value: `{{ if eq (.Type | OpenFeatureType) "object"}}{{ .DefaultValue | ToJSONString }}{{ else }}{{ .DefaultValue }}{{ end }}`
   *
   * @param domain - Optional domain for flag evaluation (scopes the flag to a specific provider).
   * @param options - Optional configuration for the flag evaluation.
   * @returns An Observable that emits EvaluationDetails whenever the flag value changes.
   */
  get{{ .Key | ToPascal }}Details(
    domain?: string,
    options?: AngularFlagEvaluationOptions
  ): Observable<EvaluationDetails<{{ if eq (.Type | OpenFeatureType) "object" }}JsonValue{{ else }}{{ .Type | OpenFeatureType }}{{ end }}>> {
    return this.flagService.{{ .Type | SdkServiceMethod }}(
      {{ .Key | Quote }},
      {{ if eq (.Type | OpenFeatureType) "object"}}{{ .DefaultValue | ToJSONString }}{{ else }}{{ .DefaultValue | QuoteString }}{{ end }},
      domain,
      {
        updateOnConfigurationChanged: options?.updateOnConfigurationChanged ?? true,
        updateOnContextChanged: options?.updateOnContextChanged ?? true,
      }
    );
  }
{{ end }}
}

// ============================================================================
// GENERATED STRUCTURAL DIRECTIVES
// ============================================================================

{{ range .Flagset.Flags }}
{{- $type := .Type | OpenFeatureType -}}
{{- $directiveType := "" -}}
{{- $directivePrefix := "" -}}
{{- if eq $type "boolean" -}}
  {{- $directiveType = "BooleanFeatureFlagDirective" -}}
  {{- $directivePrefix = "booleanFeatureFlag" -}}
{{- else if eq $type "string" -}}
  {{- $directiveType = "StringFeatureFlagDirective" -}}
  {{- $directivePrefix = "stringFeatureFlag" -}}
{{- else if eq $type "number" -}}
  {{- $directiveType = "NumberFeatureFlagDirective" -}}
  {{- $directivePrefix = "numberFeatureFlag" -}}
{{- else -}}
  {{- $directiveType = "ObjectFeatureFlagDirective" -}}
  {{- $directivePrefix = "objectFeatureFlag" -}}
{{- end }}
/**
 * Structural directive for the `{{ .Key }}` feature flag.
 *
 * {{ if .Description }}{{ .Description }}{{ else }}Feature flag directive.{{ end }}
 *
 * This directive wraps the `{{ $directiveType }}` from @openfeature/angular-sdk
 * with pre-configured flag key and default value.
 *
 * **Details:**
 * - Flag key: `{{ .Key }}`
 * - Type: `{{ if eq $type "object" }}JsonValue{{ else }}{{ $type }}{{ end }}`
 * - Default value: `{{ if eq $type "object"}}{{ .DefaultValue | ToJSONString }}{{ else }}{{ .DefaultValue }}{{ end }}`
 *
 * @example
 * Basic usage:
 * ```html
 * <div *{{ .Key | ToCamel }}>
 *   Content shown when flag is {{ if eq $type "boolean" }}enabled{{ else }}matched{{ end }}.
 * </div>
 * ```
 *
 * @example
 * With else template:
 * ```html
 * <div *{{ .Key | ToCamel }}="else: disabledTemplate">
 *   Content shown when flag is {{ if eq $type "boolean" }}enabled{{ else }}matched{{ end }}.
 * </div>
 * <ng-template #disabledTemplate>
 *   Content shown when flag is {{ if eq $type "boolean" }}disabled{{ else }}not matched{{ end }}.
 * </ng-template>
 * ```
 *
 * @example
 * With all options:
 * ```html
 * <div *{{ .Key | ToCamel }}="{{ if ne $type "boolean" }}value: expectedValue; {{ end }}else: elseTemplate;
 * initializing: initTemplate;
 * reconciling: reconcilingTemplate;
 * let value;
 * let details = evaluationDetails">
 *   Flag value: {{ "{{" }} value {{ "}}" }}
 * </div>
 * ```
 */
@Directive({
  selector: '[{{ .Key | ToCamel }}]',
  standalone: true,
  hostDirectives: [
    {
      directive: {{ $directiveType }},
      inputs: [
        '{{ $directivePrefix }}Domain: {{ .Key | ToCamel }}Domain',
        '{{ $directivePrefix }}UpdateOnConfigurationChanged: {{ .Key | ToCamel }}UpdateOnConfigurationChanged',
        '{{ $directivePrefix }}UpdateOnContextChanged: {{ .Key | ToCamel }}UpdateOnContextChanged',
        '{{ $directivePrefix }}Else: {{ .Key | ToCamel }}Else',
        '{{ $directivePrefix }}Initializing: {{ .Key | ToCamel }}Initializing',
        '{{ $directivePrefix }}Reconciling: {{ .Key | ToCamel }}Reconciling',
{{- if ne $type "boolean" }}
        '{{ $directivePrefix }}Value: {{ .Key | ToCamel }}Value',
{{- end }}
      ],
    },
  ],
})
export class {{ .Key | ToPascal }}Directive {
  private readonly hostDirective = inject({{ $directiveType }});

  constructor() {
    // Set the pre-configured flag key and default value
    this.hostDirective.{{ $directivePrefix }} = {{ .Key | Quote }};
    this.hostDirective.{{ $directivePrefix }}Default = {{ if eq $type "object"}}{{ .DefaultValue | ToJSONString }}{{ else }}{{ .DefaultValue | QuoteString }}{{ end }};
  }
}
{{ end }}

// ============================================================================
// EXPORTS
// ============================================================================

/**
 * Array of all generated feature flag directives.
 * Import this in your module or standalone component to use the directives.
 *
 * @example
 * ```typescript
 * @Component({
 *   standalone: true,
 *   imports: [GeneratedFeatureFlagDirectives],
 *   template: `<div *myFeatureFlag>...</div>`
 * })
 * export class MyComponent {}
 * ```
 */
export const GeneratedFeatureFlagDirectives = [
{{- range .Flagset.Flags }}
  {{ .Key | ToPascal }}Directive,
{{- end }}
] as const;
